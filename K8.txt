1. Build the docker image
docker build -t <your-image-name>:<tag> .

2.	Push the image to a container registry (e.g., Docker Hub, AWS ECR, or GCR):
docker tag <your-image-name>:<tag> <registry>/<your-image-name>:<tag>
docker push <registry>/<your-image-name>:<tag>

3. Set Up a Kubernetes Cluster
kubectl config view
kubectl get nodes

4. Create Kubernetes Manifests
  a. Deployment.yaml
This defines the pods and their replicas.

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: <registry>/<your-image-name>:<tag>
        ports:
        - containerPort: 80
b. Services.yaml (This exposes your application inside or outside the cluster.) 
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer # or NodePort for local clusters

5. Apply the Manifests

	1.	Save your YAML files (e.g., deployment.yaml and service.yaml).
	2.	Apply them using kubectl:

      kubectl apply -f deployment.yaml
      kubectl apply -f service.yaml
  3. Verify the deployment:
      kubectl get pods
      kubectl get services

6. Access the application 
  A. 	•	If using LoadBalancer, note the external IP:
kubectl get svc my-app-service
  B. 	•	For NodePort, access the application using the Node IP and exposed port:
minikube service my-app-service

7. Iterate and Scale

	•	Update your Docker image as needed and push the new version.
	•	Update your deployment image:
